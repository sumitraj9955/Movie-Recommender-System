# -*- coding: utf-8 -*-
"""Movie_Recommender_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r4f2Z_UkdYXXKTo3OLE7jhRgUpqcUCzQ
"""

#importing libralies
import numpy as np
import pandas as pd

movies=pd.read_csv('tmdb_5000_movies.csv')
credits=pd.read_csv('tmdb_5000_credits.csv')
movies.head(1)#this will give details of 1 movie

credits.head(1)

#merging both dataset into one
movies=movies.merge(credits,on='title')#on the basis of title

movies.shape

movies.head(1)

#kon kon row important hai and kon nhi
#not important=budget,homepage,production_companies,production_countries,runtime....
#important=geners(kisi ko horror pasand hoga to kisi ko romantic),

#id(iske throug hm movie ka poster fetch karnege),keywords,title,overview,cast(on the basis of actor),crew

movies=movies[['movie_id','title','overview','genres','keywords','cast','crew']]

movies.head()

#missing data
movies.isnull().sum()

#droping the missing data
movies.dropna(inplace=True)#hmne 3 movie hta diya jiska overview hmare pass nhi tha

movies.isnull().sum()

#checking if duplicate data exist
movies.duplicated().sum()

#since movies.duplicated().sum() iska output 0 aaya hai mtlb koi v row duplicate nhi hai

#preprocessing genres column
movies.iloc[0].genres

#hme [{"id": 28, "name": "Action"}, {"id": 12, "name": "Adventure"}, {"id": 14, "name": "Fantasy"}, {"id": 878, "name": "Science Fiction"}]
#isko ['Action','Adventure','Fantasy','Action','SciFi'] is format me laana hai id ye sb ko hatana hai

import ast
def convert(obj):
    L=[]
    for i in ast.literal_eval(obj):
        L.append(i['name'])
    return L

movies['genres']=movies['genres'].apply(convert)

movies.head()

#now hmlog same chij keywords wale column ke liye karenge
movies['keywords']=movies['keywords'].apply(convert)
movies.head()

#ab hme cast(hero,heroine) wala column ko shi krna hai isme hm 1st 3 item ko hi lenege
#1st 3 item ke 'name' ko lenge
def convert(obj):
    L=[]
    counter=0
    for i in ast.literal_eval(obj):
      if counter!=3:
        L.append(i['name'])
        counter+=1
      else:
        break
    return L

movies['cast']=movies['cast'].apply(convert)
movies.head()

movies['crew'][0]
#now ab hme  crew column ko shi krna hai usme hme bs director ka naam chiye

def fetch_director(obj):
  L=[]
  for i in ast.literal_eval(obj):
    if i['job']=='Director':
      L.append(i['name'])
      break
  return L

movies['crew']=movies['crew'].apply(fetch_director)
movies.head()

movies['overview'][0]

#abhi overciew string format me hai
#hme overview ka sbkuch list format me chahiye
movies['overview']=movies['overview'].apply(lambda x:x.split())
movies.head()

#now hme words ke bich ka space htana hoga mtlb genere me hai science fiction to hme science fiction ko ek word banana hoga sciencefiction aisa
movies['genres']=movies['genres'].apply(lambda x:[i.replace(" ","") for i in x])
movies['keywords']=movies['keywords'].apply(lambda x:[i.replace(" ","") for i in x])
movies['cast']=movies['cast'].apply(lambda x:[i.replace(" ","") for i in x])
movies['crew']=movies['crew'].apply(lambda x:[i.replace(" ","") for i in x])
movies.head()

#ab hm saare column ko concatante kr denge ek new column me jiska naam 'tag' hoga
movies['tags']=movies['overview']+movies['genres']+movies['keywords']+movies['cast']+movies['crew']
movies.head()

#now ab hme genere,overview ,crew,cast keyword col ka jarurat nhi hai tag mw hi aa gya
new_df=movies[['movie_id','title','tags']]
new_df.head()

#now ab hm tag me jo list hai usko string me convert kr lenge waapas
new_df['tags']=new_df['tags'].apply(lambda x:" ".join(x))
new_df.head()

new_df['tags'][0] #phle hmara overview hai fir genre hai fir cast and crew hai

#sb ko small letter me convert kr lete hai ->suggested hai
new_df['tags']=new_df['tags'].apply(lambda x:x.lower())
new_df.head()

"""**`Vectorization::`**




"""

#hme krna kya hai ->user ek movie ka naam batayega and uske basis pr hme 5 movie ke naam pridct krna hai
#hme similarities tags ke basis pr batna hai
new_df['tags'][0]

new_df['tags'][1]

#ab hme indo movie ke text ke bich me simalarities calculate krna hai.
#1st movie and 2nd movie ke bich kitna similarities hoga ye is baat pr depend krta hai ki in dono ke text me kitna similarities hai
#So basically hme in dono text ke bich ka similarities score calculate krna hai.
#But kaise?? qki saara chij to string hai text hai but score calculate krne ke liye to value chahiye.
#1st method->ek trika ye hai ki hm dono movie me no of matching word calculate kre.But ye aacha tarika nhi hai
#Here comes the use of vectoriazation

from sklearn.feature_extraction.text import CountVectorizer
cv=CountVectorizer(max_features=5000,stop_words='english')

vectors = cv.fit_transform(new_df['tags']).toarray()
vectors

vectors.shape

vectors[0]#it is avatar

cv.get_feature_names_out()#it will give the 1st 5000 maximum freq word in our whole tag=tag1+tag2...

#yha hme 2 issues hai 1st actions and action same word  hai but ye alag alg feauters bn gye hai to inko same krna prega
#so yha hm steaming ka use krenge isse kya hoga ??
#[loved,loving,love] iske bdle  [love,love,love]
#iske liye hme ek library import krna parega

import nltk
from nltk.stem.porter import PorterStemmer
ps=PorterStemmer()

def stem(text):
  y=[]
  for i in text.split():
    y.append(ps.stem(i))
  return " ".join(y)

ps.stem('loved')

ps.stem('dancing')

new_df['tags']=new_df['tags'].apply(stem)

cv.get_feature_names_out()

#ab hm hr movie ka hr ek ke saath distnace nikalenge .Hm yha Euclidian distance nhi nikalenge
#Hm yha 2 movie ke bich ka  angle nikalenge istend of there tip to tip distance(Euclidian distnace)
#Angle between 2 vector is called cosine angle.Angle jitna km hoga similarities utna jayda hoga
#Jb v hm high dimension space me deal krte hai to wha Euclidean distance fail ho jaata hai .Not reliable
#TO find angle between two vector hm library use kareng

from sklearn.metrics.pairwise import cosine_similarity
similarity=cosine_similarity(vectors)
similarity.shape

similarity[0]#ye hme 1st movie ka saare movie se similarities bta rha hai
#1st movie ka 1st movie se similarities 1 hai

#Finding the index of the searched movie first
new_df[new_df['title']=='Avatar'].index[0]

new_df[new_df['title']=='Batman Begins'].index[0]

#now  agr hm sort kr denge to similarities ko to fir pta kaise chalega ki kis movie ka kis se kitna similarities hai
#index position loose ho jaayega
list(enumerate(similarity[0]))

sorted(list(enumerate(similarity[0])),reverse=True,key=lambda x:x[1])

#hme bs 1st 5 movies chahiye
sorted(list(enumerate(similarity[0])),reverse=True,key=lambda x:x[1])[1:6]

def recommend(movie):
  movie_index=new_df[new_df['title']==movie].index[0]
  distances=similarity[movie_index]
  movies_list=sorted(list(enumerate(distances)),reverse=True,key=lambda x:x[1])[1:6]
  for i in movies_list:
    print(i[0])
  return

recommend('Avatar')

new_df.iloc[1216].title

def recommend(movie):
  movie_index=new_df[new_df['title']==movie].index[0]
  distances=similarity[movie_index]
  movies_list=sorted(list(enumerate(distances)),reverse=True,key=lambda x:x[1])[1:6]
  for i in movies_list:
    print(new_df.iloc[i[0]].title)
  return

recommend('Avatar')

recommend('Batman Begins')

import pickle

pickle.dump(new_df.to_dict(),open('movies_dict.pkl','wb'))

new_df['title'].values

pickle.dump(similarity,open('similarity.pkl','wb'))

